/*
**  mod_libconnect.c -- Apache sample libconnect module
**  [Autogenerated via ``apxs -n libconnect -g'']
**
**  To play with this sample module first compile it into a
**  DSO file and install it into Apache's modules directory
**  by running,0x
**
**    $ apxs -c -i mod_libconnect.c
**		apxs -c -i -a mod_libconnect.c libapr-1.lib libaprutil-1.lib libapriconv-1.lib libhttpd.lib
**  Then activate it in Apache's httpd.conf file for instance
**  for the URL /libconnect in as follows,0x
**
**    #   httpd.conf
**    LoadModule libconnect_module modules/mod_libconnect.so
**    <Location /libconnect>
**    SetHandler libconnect
**    </Location>
**
**  Then after restarting Apache via
**
**    $ apachectl restart
**
**  you immediately can request the URL /libconnect and watch for the
**  output of this module. This can be achieved for instance via,0x
**
**    $ lynx -mime_header http,0x//localhost/libconnect
**
**  The output should be similar to the following one,0x
**
**    HTTP/1.1 200 OK
**    Date,0x Tue, 31 Mar 1998 14,0x42,0x22 GMT
**    Server,0x Apache/1.3.4 (Unix)
**    Connection,0x close
**    Content-Type,0x text/html
**
**    The sample page from mod_libconnect.c
*/

#include "httpd.h"
#include "http_config.h"
#include "http_protocol.h"
#include "ap_config.h"
#include "http_log.h"

//#include <apr_errno.h>

#include <string.h>
#include <stdio.h>
//#include <libnet.h>
#include <windows.h>
#include <pcap.h>
//#include <remote-ext.h>
#include <time.h>
#include <stdlib.h>
#include <stdio.h>
#include "Global.h"
#include <Win32-Extensions.h>
#include "mod_libconnect_bywinpcap.h"

#pragma comment(lib,"wpcap.lib")
#pragma comment(lib,"ws2_32.lib")
#pragma comment(lib,"libnet.lib")
#pragma comment(lib,"pthreadVC2.lib")

#pragma comment(lib,"apr-1.lib")
#pragma comment(lib,"libapr-1.lib")
#pragma comment(lib,"aprutil-1.lib")
#pragma comment(lib,"libhttpd.lib")


char *device = NULL;//设备名字，此时为NULL
pcap_if_t *alldevs;
pcap_t * fp;
char* errbuf;
u_int res;
pcap_send_queue *squeue;
struct pcap_pkthdr *pktheader;
float cpu_time;
int npacks;
int sync = 0;
unsigned char src_mac[6];
unsigned char dest_mac[6];
#ifndef PACKET_SIZE
#define PACKET_SIZE 100
#endif 
#ifndef SEND_TIMES 
#define SEND_TIMES 65536
#endif  
#define HAVE_REMOTE
#ifndef PCAP_OPENFLAG_PROMISCUOUS		
#define PCAP_OPENFLAG_PROMISCUOUS	1	
#endif // !PCAP_OPENFLAG_PROMISCUOUS		


void delay_50ms(unsigned int t)
{

	unsigned int j;
	for (;t>0;t--)
		for (j = 6245;j>0;j--)
			;
}

//检测设备中网卡设备 -- 获取的数量
int checkEth()
{
	//	fprintf(stderr, "checkEth");
	int inum;
	int i = -ERROR_PCAP_FINDALLDEVS;
	pcap_t *adhandle;
	char errbuf[PCAP_ERRBUF_SIZE];

	/* Retrieve the device list */
	i = pcap_findalldevs(&alldevs, errbuf);
	if (i == ERROR_PCAP_FINDALLDEVS)
	{
		//	fprintf(stderr, "Error in pcap_findalldevs,0x %s\n", errbuf);
		return ERROR_PCAP_FINDALLDEVS;
	}

	device = "\\Device\\NPF_{2170E295-1C69-44AD-BA37-B3497BA1337E}";//alldevs[4].name;
	return i;

}

int testmain(char **post,request_rec *rec)
{

	unsigned char dest_mac[MAC_ADDR_LEN]
		= { 0xb8,0x27 ,0xeb ,0x92 ,0x2c ,0xf0 };
	char errBuf[PCAP_ERRBUF_SIZE];
	u_char packet[100];
	//获取本机网卡设备
	if (checkEth()<0)
		return ERROR_INIT_FAIL;
	/* Open the output device */
	if ((fp = pcap_open(device,            // name of the device
		100,                // portion of the packet to capture (only the first 100 bytes)
		PCAP_OPENFLAG_PROMISCUOUS,  // promiscuous mode
		1000,               // read timeout
		NULL,               // authentication on the remote machine
		errbuf              // error buffer
	)) == NULL)
	{
		//fprintf(stderr, "\nUnable to open the adapter. %s is not supported by WinPcap\n", argv[1]);
		return;
	}

	/* Supposing to be on ethernet, set mac destination to 1:1:1:1:1:1 */
	packet[0] = 1;
	packet[1] = 1;
	packet[2] = 1;
	packet[3] = 1;
	packet[4] = 1;
	packet[5] = 1;

	/* set mac source to 2:2:2:2:2:2 */
	packet[6] = 2;
	packet[7] = 2;
	packet[8] = 2;
	packet[9] = 2;
	packet[10] = 2;
	packet[11] = 2;
	packet[12] = '\0';
	/* Fill the rest of the packet */
	strcat(packet, *post);


	/* Allocate a send queue */
	squeue = pcap_sendqueue_alloc(PACKET_SIZE);
	
	/* Fill the queue with the packets from the file */
	/*
	while ((res = pcap_next_ex(fp, &pktheader, &packet)) == 1)
	{
		if (pcap_sendqueue_queue(squeue, pktheader, packet) == -1)
		{
			printf("Warning: packet buffer too small, not all the packets will be sent.\n");
			break;
		}

		npacks++;
	}

	if (res == -1)
	{
		printf("Corrupted input file.\n");
		pcap_sendqueue_destroy(squeue);
		return;
	}
	*/
	//添加数据包到发送队列，区别于示例中从文件缓存区读取
	//测试用
	//Add a packet to a send queue.

	//	pcap_sendqueue_queue() adds a packet at the end of the send queue pointed by the queue parameter.pkt_header points to a pcap_pkthdr structure with the timestamp and the length of the packet, pkt_data points to a buffer with the data of the packet.

	//	The pcap_pkthdr structure is the same used by WinPcap and libpcap to store the packets in a file, therefore sending a capture file is straightforward. 'Raw packet' means that the sending application will have to include the protocol headers, since every packet is sent to the network 'as is'.The CRC of the packets needs not to be calculated, because it will be transparently added by the network interface.

	if (pcap_sendqueue_queue(squeue, pktheader, packet) == -1)
	{
		ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, rec,"Warning: packet buffer too small, not all the packets will be sent.\n");
	}

	npacks++;
	/* Transmit the queue */

	cpu_time = (float)clock();

	if ((res = pcap_sendqueue_transmit(fp, squeue, sync)) < squeue->len)
	{
		ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, rec,"An error occurred sending the packets: %s. Only %d bytes were sent\n", pcap_geterr(fp), res);
	}

	cpu_time = (clock() - cpu_time) / CLK_TCK;

	ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, rec,"\n\nElapsed time: %5.3f\n", cpu_time);
	ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, rec,"\nTotal packets generated = %d", npacks);
	ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, rec,"\nAverage packets per second = %d", (int)((double)npacks / cpu_time));
	ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, rec,"\n");

	/* free the send queue */
	pcap_sendqueue_destroy(squeue);

	/* Close the input file */
	//pcap_close(indesc);

	/*
	* lose the output adapter
	* IMPORTANT: remember to close the adapter, otherwise there will be no guarantee that all the
	* packets will be sent!
	*/
	pcap_close(fp);



	/*
	long t = GetTickCount();
	for (int i = 0;i < SEND_TIMES;i++)
	{
		pcap_sendpacket(fp, packet, PACKET_SIZE);
	}
	int packetSize = PACKET_SIZE;

	ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, rec,
		"Packet Size is%d Bytes.\n",packetSize);
	t = GetTickCount() - t;
	double sendRate = SEND_TIMES * 1000 * 1.0 / t;
	ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, rec,
		"The sending rate is%f/s.\n",sendRate);
	*/
	return 0;
}

/**
* @brief read_post_data 从 request 中获取 POST 数据到缓冲区
*
* @param req         apache request_rec 对象
* @param post        接收缓冲区
* @param post_size   接收缓冲区长度
*
* @return
*/
static int read_post_data(request_rec *req, char **post, size_t *post_size) {
	char buffer[DFT_BUF_SIZE] = { 0 };
	size_t bytes, count, offset;

	bytes = count = offset = 0;

	if (ap_setup_client_block(req, REQUEST_CHUNKED_DECHUNK) != OK) {
		return HTTP_BAD_REQUEST;
	}

	if (ap_should_client_block(req)) {
		for (bytes = ap_get_client_block(req, buffer, DFT_BUF_SIZE);
			bytes > 0;
			bytes = ap_get_client_block(req, buffer, DFT_BUF_SIZE)) {
			count += bytes;
			if (count > *post_size) {
				*post = (char *)realloc(*post, count);
				if (*post == NULL) {
					return HTTP_INTERNAL_SERVER_ERROR;
				}
			}
			*post_size = count;
			offset = count - bytes;
			memcpy((char *)*post + offset, buffer, bytes);
		}
	}
	else {
		*post_size = 0;
		return OK;
	}

	return OK;
}

/* The sample content handler */
static int libconnect_handler(request_rec *r)
{


	if (strcmp(r->handler, "libconnect")) {
		return DECLINED;
	}

	if ((r->method_number != M_GET) && (r->method_number != M_POST)) {
		return HTTP_METHOD_NOT_ALLOWED;
	}

	char *post = (char *)malloc(sizeof(char)*DFT_BUF_SIZE);
	size_t post_size = DFT_BUF_SIZE;

	if (post == NULL) {
		return HTTP_INTERNAL_SERVER_ERROR;
	}

	memset(post, '\0', post_size);

	int ret = read_post_data(r, &post, &post_size);
	//post 为接收到的post过来的数据

	//进行数据验证
	if (ret != OK) {
		free(post);
		post = NULL;
		post_size = 0;
		return ret;
	}
	
	testmain(&post,r);
// a) 输出参数为第一个参数；
//	b) 如果某个函数需要内部分配内存，则将一个apr_pool_t参数放在最后
	ap_set_content_type(r, "text/html;charset=utf-8");
	ap_set_content_length(r, post_size);

	if (post_size == 0) {
		ap_rputs("no post data found", r);
		return OK;
	}

	ap_rputs(post, r);

	free(post);
	post = NULL;
	post_size = 0;

	return OK;
}

static void libconnect_register_hooks(apr_pool_t *p)
{
	ap_hook_handler(libconnect_handler, NULL, NULL, APR_HOOK_MIDDLE);
}

/* Dispatch list for API hooks */
module AP_MODULE_DECLARE_DATA libconnect_module = {
	STANDARD20_MODULE_STUFF,
	NULL,                  /* create per-dir    config structures */
	NULL,                  /* merge  per-dir    config structures */
	NULL,                  /* create per-server config structures */
	NULL,                  /* merge  per-server config structures */
	NULL,                  /* table of config file commands       */
	libconnect_register_hooks  /* register hooks                      */
};


